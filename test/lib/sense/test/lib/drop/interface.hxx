namespace om636 {
/////////////////////////////////////////////////////////////////////////////////////////////
/* sign(a, b) == sign( a - b ) */
/////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
int sign(const T& a)
{
    if (a == 0)
        return 0;
    else if (a > 0)
        return 1;
    return -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
int cmp(const T& a, const T& b)
{
    if (a == b)
        return 0;
    else if (a > b)
        return 1;
    return -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class U>
int cmp(const T& a, const U& b)
{
    if (a == b)
        return 0;
    else if (a > b)
        return 1;
    return -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
T gcd(const T& a, const T& b)
{
    return euclidian(a, b);
}

/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
T euclidian(T a, T b)
{
    using std::swap;

    if (b > a)
        swap(a, b);

    ASSERT(b != 0);

    for (T r(a % b); r != 0; r = a % b) {
        a = b;
        b = r;
    }
    return b;
}

/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
template <class T, class O>
std::pair<T, O> euclidian(T a, T b, O out)
{
    using std::swap;

    if (b > a)
        swap(a, b);
    assert(b != 0);

    for (T r = a % b; r != 0; r = a % b) {
        *(out++) = a / b;
        a = b;
        b = r;
    }
    *(out++) = a / b;
    return std::make_pair(b, out);
}
} // om636